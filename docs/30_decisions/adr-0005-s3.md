
<div class="tr1l-participants" aria-label="participants">
  <a class="tr1l-chip" href="https://github.com/marulog" aria-label="박준희 GitHub">
    <img class="tr1l-avatar" src="https://github.com/marulog.png?size=120" alt="박준희" />
    <span class="tr1l-name">박준희</span>
  </a>
</div>

<style>
  .tr1l-participants{
    display:flex; flex-wrap:wrap; gap:10px;
    align-items:center; margin:8px 0 2px;
  }
  .tr1l-chip{
    display:inline-flex; align-items:center; gap:10px;
    padding:8px 12px; border-radius:999px;
    text-decoration:none !important;
    border:1px solid rgba(127,127,127,.28);
    background:rgba(127,127,127,.10);
    backdrop-filter:saturate(140%) blur(4px);
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
  }
  .tr1l-chip:hover{
    transform:translateY(-1px);
    border-color:rgba(127,127,127,.45);
    background:rgba(127,127,127,.14);
  }
  .tr1l-avatar{
    width:28px; height:28px; border-radius:50%;
    display:block; flex:0 0 auto;
    box-shadow:0 0 0 1px rgba(127,127,127,.22);
  }
  .tr1l-name{
    font-weight:650; font-size:14px;
    line-height:1; letter-spacing:-0.2px;
    color:inherit;
  }
</style>
> #### 작성일 : 2026-02-06


---

## 1. Context (상황/배경)

- **어디 이야기인가요? (Scope)**: Storage
- **규모는 어느 정도인가요? (Scale)**: 
  - 월 1회 청구서 생성
  - 100만명 유저에 대한 청구서 생성
  - 각 유저에 대해서 2가지 타입의 청구서 생성 → 200만개의 청구서 생성
- **피할 수 없는 조건은? (Constraints)**:
    - 청구서 생성 이후 대부분 **불변**에 가까움 → ReadOnly
    - 정책 변경, 배치 재시도 등으로 재시도 발생 → 유저에 대한 **덮어쓰기** 필요
    - 발송 시점에 **대량 읽기**가 발생 가능(특정 시간대 몰림)
    - 청구서에는 user_id/과금정보 등 **민감정보**가 포함됨 → **접근제어** 필요
    - 배치-발송이 분리되어 있어 본문(playload)과 메타데이터(buckey/key) 분리 저장 필요

- **현재 흐름은? (Current flow)**:
    - 배치 Writer가 청구서(EMAIL HTML, SMS TXT)를 생성
    - 청구서를 Postgres, Mongo 등 DB에 적재
    - Kafka Consumer가 DB에 접근하여 해당 청구서를 획득하여 사용자에게 발송

    

---

## 2. Problem (문제)
- **증상(Symptom)**: 
  - 발송 시점에 읽기 요청이 몰리면 DB가 병목이 되기 쉬움 **(대량 읽기/동시성 증가)**
  - 청구서 본문까지 DB에 넣을 경우 DB가 파일 저장소 역할까지 하면서 **운영 부담 증가**
- **원인(Root cause)**:
    - RDB는 트랜잭션/조인/인덱싱에 특화 되어 있지만, 대량 BLOB(HTML/XT) 적재는 저장공간 증가, 백업/복구/복제 비용, I/O 증폭 등의 부담을 유발할 수 있음.
- **리스크(Risk)**: 
  - 발송 트래픽이 DB 커넥션/ IO 병목으로 번지면, 발송 장애가 DB에도 영향을 받게 됨 .
  - 장기적으로 청구서가 적재되기에 데이터 크기 증가에 따라 **백업/복구 시간, 마이그레이션** 난이도가 상승

---

## 3. Options (대안)

### Option A — S3 + Postgres
- **한 줄 요약(Summary)**: 장애 레벨 격리, 마이그레이션 편의, Prefix 기반 간편 조회 등 에서 대용량 파일 저장소로 적합.
- **좋은 점(Pros)**:
  - 객체 기반 저장으로 **bucket+key**로 쿼리 없이 단순 조회로 업로드/다운로드 가능
  - 대량 조회 상황에서 객체 단위로 쉽게 접근이 가능하여 **시스템 병목 현상**을 낮춤
  - S3 내부에서 암호화 및 생명 주기 관리로 내부 감사에서 유리
- **아쉬운 점(Cons)**:
  - 업로드(S3)와 메타 저장(DB)가 분리되어 부분 실패에 대한 추가 로직 필요
  - HTTP 네트워크 통신이기에 **재시도/백오프** 정책이 추가 필요


### Option B — Postgres
- **한 줄 요약(Summary)**: 1개의 로직으로 단순 처리 가능, TR1L의 **대용량 데이터**, **Hotshopt**에서 병목시 대응책이 미흡함. 
- **좋은 점(Pros)**: 단일 저장소로 일관성 관리가 단순함
- **아쉬운 점(Cons)**:
  - 저장 용량/백업/복구 등 운영 부담이 DB로 집중
  - 발송 트래픽(대량 읽기)이 DB 병목 가능성 존재


### Option C — IPFS
- **한 줄 요약(Summary)**: 분산 시스템 저장소로 무결성이 보장되지만, 민감 데이터에 대한 **영구 삭제 불가** 특징으로 부적합.
- **좋은 점(Pros)**:
  - 분산형 시스템으로 캐시로 인한 기존 HTTP 통신보다 조회 속도 향상 가능
  - CID 자체가 해당 파일의 무결성을 검증
- **아쉬운 점(Cons)**:
  - 업로드한 파일은 영구 삭제가 불가능
  - pinning에 따라 가용성이 변경되기에 추가적인 운영 필요

#### Quick Compare (간단 비교)

| Option           | 성능(Performance) | 안정성(Reliability) | 운영성(Operability) | 비용(Cost) | 개발(DevEx) | 결론(Verdict) |
|------------------|----------------:|-----------------:|-----------------:|---------:|----------:|-------------|
| A s3 + porstgres |               상 |               중상 |                상 |        하 |         상 | 채택          |
| B       postgres |               중 |                중 |                중 |        상 |         하 | 보류          |
| C     IPFS       |               상 |                하 |                하 |        중 |         중 | 보류          |

---

## 4. Decision (최종 선택)

- **우리는 이것을 선택했다(Decision)**: **Option A - S3 + postgres**
- **한 줄 이유(One-liner)**: **불변에 가까운 대용량 파일**을 트랜잭션 DB에서 분리하여, 발송 시점의 **대량 읽기**가 DB 병목/장애 확산으로 이어지는 위험을 막음

---

## 5. Consequences (결과/영향)
 ✅ 좋아진 점(Pros)
- DB에는 상태/메타데이터만 남아 백업 부담 완화
- 발송 트래픽은 S3로 분산되어, DB 커낵션/락/IO 병목 위험 감소
- S3의 내구성, 암호화, 장기보관 특징으로 내부 감사에 강함

### ⚠️ 감수한 점(Cons)
-  S3 요청 실패/지연에 따른 대응 필요
- S3 요청에 따른 비동기 병렬 처리 필요

### 🔧 운영 관점(Ops notes)
- Tx, Rx, S3 4xx/5xx 관측 패널 추가

---

## 6. Evidence (증빙)
현재 RBD vs IPFS vs S3의 **실측 성능 비교**는 수행하지 않았으며, 시스템 특성과 운영 리스크를 기준으로 선택하였다. 
