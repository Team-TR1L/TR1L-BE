---
title: 버린 선택지(Rejected Alternatives)
parent: 당위성/의사결정(Decisions)
nav_order: 4
---


## <span id="opt-b-mega-query"></span> OptionB - 단일 Mega Query로 한 번에 조립
### 왜 버렸나요? 
- **운영/튜닝이 너무 어려워짐 (Operability)**  
  쿼리가 길어질수록 “어디가 병목인지/어디가 튜닝 지점인지” 찾기 어렵고, 장애가 났을 때 플랜/인덱스/통계 등 변수를 한 번에 다 의심해야 했다.  
  월 정산은 매달 반복되니까, 이런 불확실성은 운영 비용으로 바로 이어진다고 판단했다.

- **재시도 경계가 흐릿해짐 (Rerun-safe)**  
  월 정산은 실패 시 재실행이 전제인데, Mega Query는 “어디까지 성공했는지”를 Step 단위로 명확히 자르기 어렵다.  
  결국 전체 재처리로 흘러가기 쉬워 데이터 정합성과 운영 안정성 측면에서 불리했다.
### Artifacts(증거)
- Before Query [adr-0001-before-query](../sql/adr-0001-flattening-join-explosion-before-query.sql)
- After Query [adr-0001-after-query](../sql/adr-0001-flattening-join-explosion-after-query.sql)
- Before Sequence Diagram
![sequence diagram](../images/Option%20Subscriptions%20Flow-2026-02-02-104119.png)

---
### 0) 옵션 선택 기준
> TR1L 팀은 아래와 같은 기준으로 옵션을 판단했다.

1. Job2에서는 절대 재계산이 발생해서는 안된다.
   - 청구서 1건에 = 1회 조회로 끝나는가(조인/다중 쿼리 재실행 여부)
2. 월초 피크에서 장애 반경을 줄일 수 있는가
   - Postgres 부하와 결과 스냅샷 부하가 한 곳에 결합되지 않는지
3. 재시도 비용이 폭증하지 않는가
   - S3 업로드 실패 시 "**청구서 계산부터 다시**"가 아니라 스냅샷만을 조회해서 재업로드가 가능한지
4. 정책(요금제, 할인 정책등) 변경에 대응 가능한가
   - 테이블 분해/조인 구조 변경 비용이 누적되지 않는가
5. 운영 난이도 대비 얻는 가치가 더 높은가
   - 모니터링/알림/백업 등 운영 난이도 증가를 감수할 수 있는가

## <span id="opt-b-same-rds"></span> OptionB - RDS(PostgreSQL) JSONB (동일 클러스터 내 저장)
### 왜 버렸나요?
**1. ✅JSONB로도 문서 스냅샷은 가능하다.(예시 테이블 구조는 아래에)** 
```sql
CREATE TABLE billing_snapshot (
  billing_month   varchar(7)  NOT NULL,
  user_id         bigint      NOT NULL,
  schema_version  int         NOT NULL,
  payload         jsonb       NOT NULL,
  
  created_at      timestamptz NOT NULL DEFAULT now(),
  updated_at      timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (billing_month, user_id)
);
```

**2. ❌워크로드 결합으로 인해 **성능 저하**와 **장애 확산 가능성**이 존재한다.** 
- 동일 Postgres가 담당하는 워크로드는 아래와 같다.
  - Step01: 입력값 평탄화(대량 조인+적재)
  - Step02: 선점 테이블(billing_work) 업데이트
- 월초(청구서 정산) 피크 상황에서 아래 요인들을 고려해야 한다.
  1. 쓰기 증폭 : 
     - 대량의 upsert(청구서 스냅샷)은 WAL를 급증시켜 I/O 스파이크 유발 가능
     - payload가 커질수록 페이지 분리 및 테이블 관리 부담이 커짐.
  2. 캐시 I/O 경쟁 심화:
     - Step01은 조인과 대량 스캔의 성격이 강하며, Job2는 단건 조회가 많이 발생한다 이러한 과정에서 IO saturation → 큐 적체 → tail 증가 가능성 존재.
  3. 전체 파이프라인으로 장애 확산:
     - 동일 RDS에서 운영 장애 발생 시 Job1,Job2 모두가 장애가 전파될 가능성 존재

**3. ✅재시도 관점에서 동일하다.**
- 월 정산은 S3 저장 실패와 같은 외부 I/O 실패가 발생한다. 이때, 재처리 비용을 최소화해야된다.
- **Trigger 동작**으로서 Job1의 작업이 실패없이 완료된 후에 Job2가 실행되므로 Job2에서 S3 업로드가 실패하더라고 다른 방법들과 동일하게 해당 스냅샷만 조회하면된다.

**4. ✅정책 변경에 대해서 변경 사항이 비교적 적다.**
- 스냅샷이 JSONB로 “결과 자체”를 담는 구조라면, 정책 변경(요금제/할인 정책 등)은 보통 다음 월 스냅샷부터 반영되며 기존 스냅샷은 그대로 보존된다.
- 스키마 진화가 필요할 경우에도 schema_version으로 버전 관리가 가능하여, 테이블 분해/조인 구조 변경 같은 큰 비용은 발생하지 않는다.

**5. 😕운영 난이도는 낮지만, MongoDB 대비 얻는 가치(안정성/확장성)는 제한적이다.**
- 기존 RDS 스키마에 `billing_snapshot` 테이블만 추가하면 되고,
- 모니터링/알림/백업 등 운영 체계도 기존 Postgres와 동일하게 가져갈 수 있어 **운영 난이도 자체는 가장 쉽다.**
- 다만 “**동일 클러스터 내 저장**”인 이상, 월초 피크에서 스냅샷 write/read가 기존 Postgres 워크로드와 결합되어
  - 2번 기준(장애 반경 축소)을 만족시키기 어렵고,
  - 결과적으로 운영이 쉬운 만큼 **얻는 안정성/예측 가능성의 이득은 MongoDB 대비 제한적**이다.
- 즉, **운영은 쉽지만**, 월초 피크에서 “성능 변동 + 장애 확산” 리스크를 구조적으로 제거하지 못한다.


> **결론**
> 
> 2번의 기준(장애 확산)을 충족시키지 못해 기각했다.


---

## <span id="opt-c-different-rds"></span> Option C — RDS(Postgres) 별도 클러스터(스냅샷 전용) + JSONB

**1. ✅Job2에서 재계산이 발생하지 않도록 만들 수 있다.**
- OptionB와 동일하게, 청구서 결과를 JSONB로 저장하면 Job2는 청구서 1건 = 1회 조회로 처리할 수 있다.
- 조인/다중 쿼리 재실행 없이 스냅샷 단건 조회로 렌더링/업로드가 가능하다.

**2. ✅월초 피크에서 장애 반경을 줄일 수 있다.**
- 스냅샷 전용 RDS를 별도로 두면, 메인 Postgres(입력 평탄화/상태 업데이트/사용량 조회) 워크로드와 스냅샷 write/read 워크로드가 분리된다.
- 따라서 메인 DB의 조인/상태 병목이 Job2 조회 부하로 증폭되거나, 반대로 스냅샷 DB 이슈가 메인 DB로 전파되는 경로를 줄일 수 있다.


**3. ✅재시도 비용 관점에서도 요구사항을 만족할 수 있다.**
- S3 업로드 실패 시 계산을 다시 수행할 필요 없이, 스냅샷 전용 RDS에서 동일한 문서를 재조회하여 재업로드하면 된다.
- 재시도 부하가 메인 Postgres로 다시 집중되지 않는다는 점에서 OptionB보다 더 안정적이다.

**4. ✅정책 변경에 대해서 변경 사항이 비교적 적다.**
- 결과 스냅샷(JSONB) 구조는 정책 변경에 대해 “다음 월부터 반영, 기존 월은 보존”이 자연스럽다.
- 필드 확장/변경이 필요한 경우 schema_version 기반의 버전 관리로 대응 가능하다.

**5. ❌운영 난이도 대비 얻는 가치가 MongoDB 대비 낮다. (정책/모델 변화 리스크 관점)**
- 정산 로직은 “날짜/기간”에 따라 정책이 늘어나고(할인/요금 정책 추가/삭제/변경), 베이스 항목들이 변경될 수 있다.
- 정산 시스템에서 가장 위험한 경우는 단순 성능 문제가 아니라,
  **정책 변화 → 데이터 모델 변경 → 운영 장애**(재계산/누락/중복/정합성 깨짐)로 이어지는 시나리오다.
- Option C(Postgres + JSONB)는 “별도 RDS로 격리”는 확보하지만,
  - 결과를 Postgres 테이블에 저장하는 이상, 정책/결과 구조 변화가 커질수록
    JSONB 구조 버전 관리 + 호환 로직 + 마이그레이션/검증 같은 운영 작업이 누적되기 쉽다.
  - 즉, 저장소를 추가로 운영하는 비용을 지불하면서도 “정책 변화가 시스템을 흔드는 위험”을 충분히 낮추지 못한다.
- Option A(MongoDB)는 스냅샷을 **문서 1건으로 고정**해두는 방식이라,
  - 정책 변화가 생겨도 “이미 발행된 월/유저 결과”는 불변(immutable)에 가까운 스냅샷으로 남고,
  새로운 정책은 다음 실행부터 새로운 문서 스키마 버전으로 분리(예: schemaVersion)할 수 있어,
  데이터 모델 변경이 곧바로 운영 장애로 번지는 확률을 낮춘다.
- 또한 정산 결과는 관계형의 강점(복잡한 조인, 참조 무결성)이 핵심이 아니라,
  - 한 번 계산되면 대부분 불변(immutable)에 가까운 스냅샷이며, 읽을 때도 재조합보다 단건 조회가 더 중요하다. 이 소비 모델에 **MongoDB**가 더 자연스럽다.

> **결론**
>
> Option C는 2번 기준(장애 반경 축소)은 충족하지만,
> “정책/데이터 모델 변화가 운영 장애로 전파되는 위험”을 낮추는 효과가 MongoDB 대비 약하고,
> 결과 스냅샷의 데이터 성격(불변 스냅샷, 단건 조회 소비)에 더 자연스러운 Option A가 적합하다고 판단해 기각했다.

---
